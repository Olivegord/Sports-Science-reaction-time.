<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reaction Time Tester</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: #f4f5fb;
      color: #111;
      transition: background-color 180ms ease, color 180ms ease;
    }

    body.waiting {
      background: #b71c1c;
      color: #fff;
    }

    body.ready {
      background: #1b5e20;
      color: #fff;
    }

    body.rainbow-mode {
      background: linear-gradient(120deg, #ff0048, #ff7f00, #ffd300, #8f00ff, #0057ff);
      background-size: 400% 400%;
      animation: rainbow-pan 15s linear infinite;
      color: #fff;
    }

    body.rainbow-mode.waiting,
    body.rainbow-mode.ready {
      animation: none;
    }

    @keyframes rainbow-pan {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    main {
      width: min(92vw, 820px);
      margin: 3rem auto;
      padding: clamp(1.5rem, 4vw, 2.75rem);
      background: rgba(255, 255, 255, 0.92);
      border-radius: 28px;
      box-shadow: 0 32px 70px rgba(15, 23, 42, 0.12);
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    body.waiting main,
    body.ready main {
      background: rgba(0, 0, 0, 0.45);
      color: inherit;
    }

    body.rainbow-mode main {
      background: rgba(0, 0, 0, 0.35);
      color: #fff;
    }

    h1 {
      margin: 0 0 0.75rem;
      font-size: clamp(2.2rem, 6vw, 3.4rem);
      font-weight: 700;
    }

    p {
      margin: 0.5rem 0 0;
      line-height: 1.6;
      font-size: 1.05rem;
    }

    #status {
      margin: 1.5rem 0 0;
      font-size: clamp(1.1rem, 3vw, 1.5rem);
      font-weight: 600;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.9rem 2.8rem;
      font-size: 1.1rem;
      font-weight: 600;
      background: linear-gradient(135deg, #1e88e5, #6a1b9a);
      color: #fff;
      cursor: pointer;
      margin-top: 2rem;
      transition: transform 140ms ease, box-shadow 140ms ease;
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    button:hover:enabled {
      transform: translateY(-2px);
      box-shadow: 0 18px 36px rgba(30, 136, 229, 0.3);
    }

    #results {
      margin-top: 2.5rem;
      display: grid;
      gap: 1.75rem;
    }

    .set-card {
      background: rgba(30, 41, 59, 0.06);
      border-radius: 22px;
      padding: 1.5rem 1.75rem;
      text-align: left;
    }

    body.waiting .set-card,
    body.ready .set-card {
      background: rgba(255, 255, 255, 0.07);
    }

    body.rainbow-mode .set-card {
      background: rgba(255, 255, 255, 0.12);
    }

    .set-card h2 {
      margin: 0;
      font-size: 1.35rem;
    }

    .set-card table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.9rem;
    }

    .set-card th,
    .set-card td {
      padding: 0.55rem 0.6rem;
      border-bottom: 1px solid rgba(15, 23, 42, 0.1);
      font-size: 0.95rem;
    }

    .set-card tbody tr:last-child td {
      border-bottom: none;
    }

    .set-card caption {
      caption-side: bottom;
      text-align: left;
      padding-top: 0.75rem;
      font-size: 0.9rem;
      opacity: 0.75;
    }

    #next-set-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.72);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      text-align: center;
      z-index: 50;
    }

    #next-set-overlay[hidden] {
      display: none;
    }

    .overlay-card {
      background: rgba(15, 23, 42, 0.88);
      border-radius: 30px;
      padding: clamp(1.75rem, 4vw, 3rem);
      width: min(92vw, 560px);
      display: grid;
      gap: 1rem;
    }

    .overlay-card h2 {
      margin: 0;
      font-size: clamp(1.65rem, 4vw, 2.4rem);
    }

    .overlay-card ul {
      margin: 0;
      padding-left: 1.3rem;
      text-align: left;
      display: grid;
      gap: 0.5rem;
      font-size: 1.05rem;
    }

    #distraction-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: grid;
      place-items: center;
    }

    #letter-x {
      font-size: clamp(4rem, 16vw, 10rem);
      font-weight: 700;
      letter-spacing: 0.1rem;
      opacity: 0;
      transition: opacity 120ms ease;
    }

    #letter-x.visible {
      opacity: 1;
    }

    #progress-track {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 18px;
      background: rgba(255, 255, 255, 0.25);
      border-radius: 0 0 18px 18px;
      overflow: hidden;
    }

    #progress-bar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #ff4081, #651fff);
      transition: width 120ms ease;
    }

    .confetti-piece {
      position: absolute;
      width: 12px;
      height: 18px;
      border-radius: 4px;
      opacity: 0;
      animation: confetti-fall 3.8s linear infinite;
    }

    @keyframes confetti-fall {
      0% { transform: translateY(-120%) rotate(0deg); opacity: 0; }
      10% { opacity: 1; }
      100% { transform: translateY(130vh) rotate(360deg); opacity: 0; }
    }

    footer {
      margin-top: 2.5rem;
      font-size: 0.95rem;
    }

    footer a {
      color: inherit;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div id="next-set-overlay" role="dialog" aria-modal="true">
    <div class="overlay-card">
      <h2 id="overlay-title">Welcome!</h2>
      <p id="overlay-summary">Press start to begin the baseline trials.</p>
      <ul id="overlay-tips"></ul>
      <button id="start-set">Start set</button>
    </div>
  </div>
  <main>
    <div id="distraction-layer" aria-hidden="true"></div>
    <h1>Reaction Time Tester</h1>
    <p>Wait for the screen to turn green, then press the <kbd>J</kbd> key as fast as you can.</p>
    <p id="status">Follow the on-screen instructions to begin.</p>
    <button id="retry" hidden>Restart experiment</button>
    <section id="results" aria-live="polite"></section>
    <footer>
      <a href="data.html">View stored data</a>
    </footer>
  </main>
  <script>
    const trialsPerSet = 6;
    const swVersion = '2024-05-08';

    const randomDelay = (min, max) => Math.random() * (max - min) + min;

    const overlay = document.getElementById('next-set-overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const overlaySummary = document.getElementById('overlay-summary');
    const overlayTips = document.getElementById('overlay-tips');
    const startSetButton = document.getElementById('start-set');
    const statusEl = document.getElementById('status');
    const resultsContainer = document.getElementById('results');
    const distractionLayer = document.getElementById('distraction-layer');
    const retryButton = document.getElementById('retry');

    const createLetterDistraction = () => {
      const letter = document.createElement('div');
      letter.id = 'letter-x';
      letter.textContent = 'X';
      distractionLayer.appendChild(letter);
      let timeoutId = null;

      const scheduleShow = () => {
        timeoutId = window.setTimeout(() => {
          letter.classList.add('visible');
        }, randomDelay(1100, 2600));
      };

      scheduleShow();

      return {
        onKey(event) {
          if (event.key.toLowerCase() === 'f' && letter.classList.contains('visible')) {
            letter.classList.remove('visible');
            window.clearTimeout(timeoutId);
            scheduleShow();
          }
        },
        cleanup() {
          window.clearTimeout(timeoutId);
          letter.remove();
        }
      };
    };

    const createProgressBarDistraction = () => {
      const track = document.createElement('div');
      track.id = 'progress-track';
      const bar = document.createElement('div');
      bar.id = 'progress-bar';
      track.appendChild(bar);
      distractionLayer.appendChild(track);

      let progress = 0;
      let animationId = null;
      let lastTime = null;

      const tick = (timestamp) => {
        if (lastTime === null) {
          lastTime = timestamp;
        }
        const delta = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        progress = Math.min(1, progress + delta * 0.08);
        bar.style.width = `${(progress * 100).toFixed(1)}%`;
        animationId = window.requestAnimationFrame(tick);
      };

      animationId = window.requestAnimationFrame(tick);

      return {
        onKey(event) {
          if (event.code === 'Space') {
            progress = Math.max(0, progress - 0.18);
            bar.style.width = `${(progress * 100).toFixed(1)}%`;
          }
        },
        cleanup() {
          window.cancelAnimationFrame(animationId);
          track.remove();
        }
      };
    };

    const createConfettiDistraction = () => {
      const colors = ['#ff0048', '#ff7f00', '#ffd300', '#8f00ff', '#0057ff'];
      const pieces = [];
      for (let i = 0; i < 45; i += 1) {
        const piece = document.createElement('div');
        piece.className = 'confetti-piece';
        piece.style.left = `${Math.random() * 100}%`;
        piece.style.animationDelay = `${Math.random() * 3.5}s`;
        piece.style.background = colors[i % colors.length];
        distractionLayer.appendChild(piece);
        pieces.push(piece);
      }

      document.body.classList.add('rainbow-mode');

      return {
        cleanup() {
          pieces.forEach((piece) => piece.remove());
          document.body.classList.remove('rainbow-mode');
        }
      };
    };

    const sets = [
      {
        key: 'baseline',
        label: 'Baseline — no distraction',
        summary: 'Measure your raw reaction time with no extras.',
        tips: [
          'Wait for the screen to turn green, then tap the J key immediately.',
          'Six trials will run back-to-back with random delays.',
        ],
      },
      {
        key: 'letter-x',
        label: 'Letter patrol — press F for the X',
        summary: 'Keep an eye out for the giant X while you still react with J.',
        tips: [
          'When the X appears, press the F key to hide it.',
          'The X returns on its own timer, separate from the green screen.',
        ],
        setup: () => createLetterDistraction(),
      },
      {
        key: 'letter-progress',
        label: 'Letter + progress bar game',
        summary: 'Manage the X and keep the progress bar from filling up.',
        tips: [
          'Press F to hide the X whenever it appears.',
          'Tap the space bar to push the progress bar back down.',
          'Reaction times are still recorded on the J key only.',
        ],
        setup: () => {
          const letter = createLetterDistraction();
          const progress = createProgressBarDistraction();
          return {
            onKey(event) {
              letter.onKey?.(event);
              progress.onKey?.(event);
            },
            cleanup() {
              letter.cleanup?.();
              progress.cleanup?.();
            }
          };
        },
      },
      {
        key: 'confetti',
        label: 'Confetti carnival',
        summary: 'All distractions combined with a rainbow confetti celebration.',
        tips: [
          'Press F to clear the X, use Space to push back the progress bar, and hit J on green.',
          'Rainbow colours never turn green to avoid confusion with the go signal.',
        ],
        setup: () => {
          const letter = createLetterDistraction();
          const progress = createProgressBarDistraction();
          const confetti = createConfettiDistraction();
          return {
            onKey(event) {
              letter.onKey?.(event);
              progress.onKey?.(event);
            },
            cleanup() {
              letter.cleanup?.();
              progress.cleanup?.();
              confetti.cleanup?.();
            }
          };
        },
      },
    ];

    const session = {
      recordedAt: new Date().toISOString(),
      trialsPerSet,
      totalSets: sets.length,
      sets: sets.map(({ key, label }) => ({ key, label, trials: [], average: null })),
      overallAverage: null,
    };

    let activeSetIndex = 0;
    let activeDistraction = null;
    let trialIndex = 0;
    let ready = false;
    let startTime = 0;
    let delayTimeout = null;
    let cooldownTimeout = null;

    const formatTime = (value) => `${value.toFixed(1)} ms`;

    const renderResults = () => {
      resultsContainer.innerHTML = '';
      session.sets.forEach((set, index) => {
        const card = document.createElement('article');
        card.className = 'set-card';
        const title = document.createElement('h2');
        title.textContent = `Set ${index + 1}: ${set.label}`;
        card.appendChild(title);
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const headRow = document.createElement('tr');
        ['Trial', 'Reaction time (ms)'].forEach((text) => {
          const th = document.createElement('th');
          th.textContent = text;
          headRow.appendChild(th);
        });
        thead.appendChild(headRow);
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        for (let t = 0; t < trialsPerSet; t += 1) {
          const row = document.createElement('tr');
          const trialCell = document.createElement('td');
          trialCell.textContent = t + 1;
          const timeCell = document.createElement('td');
          if (set.trials[t] != null) {
            timeCell.textContent = formatTime(set.trials[t]);
          } else {
            timeCell.textContent = '—';
          }
          row.appendChild(trialCell);
          row.appendChild(timeCell);
          tbody.appendChild(row);
        }
        table.appendChild(tbody);
        const caption = document.createElement('caption');
        caption.textContent = set.average != null
          ? `${trialsPerSet} trials • Average ${formatTime(set.average)}`
          : `${trialsPerSet} trials`;
        table.appendChild(caption);
        card.appendChild(table);
        resultsContainer.appendChild(card);
      });

      const recordedTimes = session.sets.flatMap((set) => set.trials);
      if (recordedTimes.length === sets.length * trialsPerSet) {
        const overall = recordedTimes.reduce((sum, value) => sum + value, 0) / recordedTimes.length;
        session.overallAverage = overall;
      }
      window.localStorage.setItem('reactionTimeSession', JSON.stringify(session));
    };

    const showOverlay = () => {
      const current = sets[activeSetIndex];
      overlayTitle.textContent = activeSetIndex === 0 ? 'Welcome!' : `Next up: Set ${activeSetIndex + 1}`;
      overlaySummary.textContent = current.summary;
      overlayTips.innerHTML = '';
      (current.tips || []).forEach((tip) => {
        const li = document.createElement('li');
        li.textContent = tip;
        overlayTips.appendChild(li);
      });
      overlay.hidden = false;
      startSetButton.focus();
    };

    const beginSet = () => {
      overlay.hidden = true;
      const current = sets[activeSetIndex];
      statusEl.textContent = `Set ${activeSetIndex + 1} of ${sets.length}. Wait for green.`;
      trialIndex = 0;
      if (activeDistraction?.cleanup) {
        activeDistraction.cleanup();
        activeDistraction = null;
      }
      if (current.setup) {
        activeDistraction = current.setup();
      } else {
        activeDistraction = null;
      }
      scheduleNextTrial();
    };

    const scheduleNextTrial = () => {
      window.clearTimeout(delayTimeout);
      window.clearTimeout(cooldownTimeout);
      ready = false;
      document.body.classList.remove('ready');
      document.body.classList.add('waiting');
      statusEl.textContent = 'Wait for green…';
      delayTimeout = window.setTimeout(() => {
        document.body.classList.remove('waiting');
        document.body.classList.add('ready');
        statusEl.textContent = 'Press J now!';
        startTime = performance.now();
        ready = true;
      }, randomDelay(1500, 3500));
    };

    const finishSet = () => {
      document.body.classList.remove('waiting', 'ready');
      ready = false;
      if (activeDistraction?.cleanup) {
        activeDistraction.cleanup();
        activeDistraction = null;
      }
      const setData = session.sets[activeSetIndex];
      if (setData.trials.length) {
        const average = setData.trials.reduce((sum, value) => sum + value, 0) / setData.trials.length;
        setData.average = average;
      }
      renderResults();

      activeSetIndex += 1;
      if (activeSetIndex < sets.length) {
        showOverlay();
      } else {
        const overallText = session.overallAverage != null ? formatTime(session.overallAverage) : '—';
        statusEl.textContent = `All done! Overall average: ${overallText}.`;
        retryButton.hidden = false;
      }
    };

    const handleReaction = (event) => {
      if (event.key.toLowerCase() === 'j') {
        if (!ready) {
          statusEl.textContent = 'Too soon! Wait for green before pressing J.';
          return;
        }
        ready = false;
        document.body.classList.remove('ready');
        const elapsed = performance.now() - startTime;
        const setData = session.sets[activeSetIndex];
        setData.trials[trialIndex] = elapsed;
        statusEl.textContent = `Reaction recorded: ${formatTime(elapsed)}.`;
        renderResults();
        trialIndex += 1;
        if (trialIndex >= trialsPerSet) {
          cooldownTimeout = window.setTimeout(finishSet, 900);
        } else {
          cooldownTimeout = window.setTimeout(scheduleNextTrial, 900);
        }
      }
    };

    const handleKeydown = (event) => {
      if (event.repeat) return;
      handleReaction(event);
      activeDistraction?.onKey?.(event);
    };

    const resetExperiment = () => {
      window.clearTimeout(delayTimeout);
      window.clearTimeout(cooldownTimeout);
      activeDistraction?.cleanup?.();
      activeDistraction = null;
      document.body.classList.remove('waiting', 'ready', 'rainbow-mode');
      session.recordedAt = new Date().toISOString();
      session.sets.forEach((set) => {
        set.trials = [];
        set.average = null;
      });
      session.overallAverage = null;
      activeSetIndex = 0;
      renderResults();
      retryButton.hidden = true;
      showOverlay();
      statusEl.textContent = 'Follow the on-screen instructions to begin.';
    };

    startSetButton.addEventListener('click', () => {
      beginSet();
    });

    retryButton.addEventListener('click', resetExperiment);
    window.addEventListener('keydown', handleKeydown);

    renderResults();
    showOverlay();

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        const swUrl = `sw.js?v=${encodeURIComponent(swVersion)}`;
        navigator.serviceWorker.register(swUrl).catch((error) => {
          console.error('Service worker registration failed', error);
        });
      });
    }
  </script>
</body>
</html>
